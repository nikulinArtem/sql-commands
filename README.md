# SQL команды

- ### Определение данных, базовые операции с данными:  
	- Изменение имени таблицы  
	  ```
	  ALTER TABLE 'table_name' RENAME TO 'new_name' ;
	  ```  
	- Изменение имени столбца  
	  ```
	  ALTER TABLE  'table_name' RENAME COLUMN 'column_name' TO 'new_column_name';
	  ```  
	- Добавление столбца в таблицу  
	  ```
	  ALTER TABLE 'table_name' ADD COLUMN 'column_name' TEXT;
	  ```  
	  > Вместо TEXT можно указать другой тип данных.  

	- Удаление таблицы  
	  ```
	  DROP TABLE 'table_name';
	  ```  
	- Простая выборка данных  
	  ```
	  SELECT 'column_1', 'column_2', 'column_n' FROM 'table_name'; 
	  ```  
	  ```
	  SELECT * FROM 'table_name';
	  ```  
	- Добавление новых данных в таблицу  
	  ```
	  INSERT INTO 'table_name' ('column_1', 'column_2', 'colum_3', 'column_n') 
	  VALUES ('value_1', 'value_2', 'value_3', 'value_n');
	  ```  
	- Вставка одной строки  
	  ```
	  INSERT INTO 'table_name' ('id', 'name', 'column_name') VALUES (1, 'value_1', 'value_2');
	  ```  
	    
	  > Если мы вставляем данные во все столбцы таблицы, то в команде INSERT  
	  имена столбцов не перечисляются:  
	  ```
	  INSERT INTO 'table_name' VALUES (1, 'value_1', 'value_2');
	  ```  

	    
	    
	  > Столбец первичного ключа id имеет признак автоинкремента, поэтому  
	  вставлять значение для id явным образом необязательно:  
	  ```
	  INSERT INTO 'table_name' VALUES ('value_1', 'value_2');
	  ```  

	- Вставка нескольких строк  
	  ```
	  INSERT INTO 'table_name' ('column_1', 'column_2') 
	  VALUES ('value_1', 'value_2'), ('value_3', 'value_4');
	  ```  
	- Обновление существующих данных  
	  ```
	  UPDATE 'table_name' SET 'column_name' = 'value' WHERE ['условие'];
	  ```  
	- Удаление данных  
	  ```
	  DELETE FROM 'table_name' WHERE ['условие'];
	  ```  
	    
	  > Если для команды DELETE не указать условие, то удалятся все строки таблицы!  

- ### Выборка и агрегация данных  
	- Условие для получения данных   
	  ```
	  SELECT * FROM 'table_name' WHERE 'column' = 'value';
	  ```  
	- Ограничение на вывод количества строк   
	  ```
	  SELECT 'column_1', 'column_2' FROM 'table_name' WHERE ['условие'] LIMIT 'число';
	  ```  
	- Сортировка результатов  
	  ```
	  SELECT * FROM 'table_name' ORDER BY [ASC / DESC];
	  ```  
	    
	  > Для сортировки по возрастанию надо дополнительно указать ASC, по убыванию  
	  — DESC  

	- Получение только уникальных результатов  
	  ```
	  SELECT DISTINCT ('column_name') FROM 'table.name';
	  ```  
	- Условие неравенства  
	  ```
	  SELECT 'column_1' FROM 'table_name' WHERE 'column_2' != 'value';
	  ```  
	  ```
	  SELECT 'column_1' FROM 'table_name' WHERE 'column_2' <> 'value';
	  ```  
	- Условие «больше или меньше»  
	  ```
	  SELECT 'column_1' FROM 'table_name' WHERE 'column_2' < 'value';
	  ```  
	  ```
	  SELECT 'column_1' FROM 'table_name' WHERE 'column_2' > 'value';
	  ```  
	- Условие по нескольким критериям  
	  ```
	  SELECT * FROM 'table_name' WHERE 'column_name' < 'value' AND 'column_name' > 'value';
	  ```  
	- Поиск по диапазону значений  
	  ```
	  SELECT 'column_1', 'column_2' FROM 'table_name' 
	  WHERE 'column_1' BETWEEN 'value_1' AND 'value_2';
	  ```  
	- Поиск по списку значений  
	    
	  > Со списками значений удобно работать с ключевым словом IN, для которого в скобках мы перечисляем все нужные значения:  
	  ```
	  SELECT 'column_1' FROM 'table_name' 
	  WHERE 'column_2' IN ('value_1', 'value_2');
	  ```  

	- Условия равенства для значения NULL  
	    
	  > IS NULL для проверки на пустое значение  
	  ```
	  SELECT 'column_1', 'column_2' FROM 'table_name' 
	  WHERE 'column_2' IS NULL;
	  ```  

	  > IS NOT NULL для проверки на непустое значение  
	  ```
	  SELECT 'column_1', 'column_2' FROM 'table_name' 
	  WHERE 'column_2' IS NOT NULL;
	  ```  

	- Арифметические операции  
	  ```
	  SELECT 'число' + 'число';
	  ```  
	  ```
	  SELECT 'число' - 'число';
	  ```  
	  ```
	  SELECT 'число' * 'число';
	  ```  
	  ```
	  SELECT 'число' / 'число';
	  ```  
	  ```
	  SELECT 'число' % 'число';
	  ```  
	- Поиск по шаблону  
	    
	  > Функция сопоставления с шаблоном LIKE:  
	  ```
	  SELECT 'column_1', 'column_2' FROM 'table_name' WHERE 'column_1' LIKE '%value%';
	  ```  

	- Получить текущее значение даты и времени  
	  ```
	  SELECT CURRENT_TIMESTAMP;
	  ```  
	-  
	  > Чтобы работать с текущей датой и временем, используются  
	  функции DATE, TIME, DATETIME со ссылкой на текущее время  
	  (‘now’):  
	  ```
	  SELECT DATE('now');
	  ```  
	  ```
	  SELECT TIME('now');
	  ```  
	  ```
	  SELECT DATETIME('now');
	  ```  

	-  
	  > Дату и время можно выделить из строки:  
	  ```
	  SELECT DATE ('2023-02-02 16:13:20');
	  ```  
	  ```
	  SELECT TIME ('2023-02-02 16:13:20');
	  ```  

	- SUBSTRING (SUBSTR)  
	    
	  > Определим, в каких позициях символов находится значение  
	  года — год начинается с позиции 1, и вырезать надо 4  
	  символа. Тогда для получения нужного значения потребуется  
	  выражение SUBSTR(CURRENT_TIMESTAMP, 1, 4):  
	  ```
	  SELECT SUBSTR(CURRENT_TIMESTAMP, 1, 4);
	  ```  

	- Нахождение среднего значения  
	  ```
	  SELECT AVG('column_name') FROM 'table_name';
	  ```  
	- Функция группировки  
	  ```
	  SELECT 'column_1', AVG('column_2') FROM 'table_name' GROUP BY 'column_1';
	  ```  
	- Подсчёт количества  
	    
	  > Чтобы подсчитать строки, определим параметром функции COUNT знак  
	  подстановки ‘звёздочка’ и сгруппируем данные в разрезе идентификаторов:  
	  ```
	  SELECT 'column_name', COUNT(*) FROM 'table_name' GROUP BY 'column_name';
	  ```  

	    
	  > Улучшим вывод, дав расчётному столбцу COUNT(*) синоним  
	  (alias) посредством ключевого слова AS:  
	  ```
	  SELECT 'column_name', COUNT(*) AS 'new_name' FROM 'table_name' GROUP BY 'column_name';
	  ```  

	- Поиск значений MAX и MIN  
	  ```
	  SELECT 'column_1', MAX ('column_2') AS 'max_column_2' 
	  FROM 'table_name'  GROUP BY 'column_1';
	  ```  
	  ```
	  SELECT 'column_1', MIN ('column_2') AS 'max_column_2' 
	  FROM 'table_name'  GROUP BY 'column_1';
	  ```  
	- Получение суммы  
	    
	  > Функция SUM() позволит найти сумму значений столбца (в этом случае группировка не нужна):  
	  ```
	  SELECT SUM ('column_name') AS 'column_total' FROM 'table_name';
	  ```  

	- Применение фильтра к расчётным значениям  
	    
	  > Чтобы определить условия для значений, рассчитываемых через функцию  
	  агрегирования, вместо WHERE применяется ключевое слово HAVING:  
	  ```
	  SELECT 'column_1', MIN ('column_2') AS 'min_column_2' 
	  FROM 'table_name' 
	  GROUP BY 'column_1' HAVING 'min_column_2' < 'value';
	  ```  

- ### Вложенные запросы и объединение UNION  
	- Вложенные запросы в части SELECT  
	  ```
	  SELECT ('Вложенный запрос') FROM ('Имя таблицы') WHERE ['Условие'];
	  ```  
	- Вложенные запросы в части FROM  
	  ```
	  SELECT 'Столбец 1', 'Столбец 2', 'Столбец n' 
	  FROM ('Вложенный запрос') WHERE ['Условие'];
	  ```  
	- Вложенные запросы в части WHERE  
	  ```
	  SELECT 'Столбец 1', 'Столбец 2', 'Столбец n' 
	  FROM 'Имя таблицы' WHERE ('Вложенный запрос');
	  ```  
	- Объединение данных через UNION  
	    
	  > Посредством оператора UNION объединим два или более запроса на выборку данных. Эти запросы  
	  могут обращаться как к одной таблице, так и к различным таблицам. Шаблон объединения с  
	  использованием UNION выглядит следующим образом:  

	  ```
	  SELECT 'Столбец 1', 'Столбец 2' FROM 'Таблица WHERE  'Условие' 
	  UNION 
	  SELECT 'Столбец 1',  'Столбец 2' FROM 'Таблица' WHERE 'Условие';
	  ```  
- ### Объединение таблиц через JOIN  
	- Перекрёстное объединение (CROSS JOIN)  
	  > При использовании CROSS JOIN мы получаем в результате объединение каждой строки левой  
	  таблицы А с каждой строкой правой таблицы В  

	  ```
	  SELECT * FROM 'Левая таблица' CROSS JOIN 'Правая таблица';
	  ```  
	- Внутреннее объединение (INNER JOIN)  
	  > При использовании внутреннего объединения INNER JOIN в результате мы получим только те данные  
	  из левой и правой таблиц, которые соответствуют условию, заданному в части ON запроса. На  
	  практике внутреннее объединение таблиц применяется наиболее часто.  

	  ```
	  SELECT * FROM 'Левая таблица' INNER JOIN 'Правая таблица' ON ['Условие'];
	  ```  
	- Левое внешнее объединение (LEFT JOIN)  
	    
	  > При использовании левого внешнего объединения LEFT JOIN мы получим все строки из левой  
	  таблицы А. Из правой таблицы В станут доступны данные, если найдётся соответствие по условию  
	  объединения ON, и появятся пустые значения для тех строк, по которым соответствия найдено не  
	  будет.  

	  ```
	  SELECT * FROM 'Левая таблица' LEFT JOIN 'Правая таблица' ON 'Условие объединения';
	  ```  
	- Правое внешнее объединение (RIGHT JOIN)  
	    
	  > При использовании правого внешнего объединения RIGHT JOIN мы получим все строки из правой  
	  таблицы В. Из левой таблицы А станут доступны данные, если найдётся соответствие по условию  
	  объединения ON, и появятся пустые значения для строк, по которым соответствия найдено не будет.  
	  Для любого запроса можно менять тип объединения с LEFT на RIGHT и обратно, меняя местами  
	  левую и правую таблицы в объединении  

	  ```
	  SELECT * FROM 'Левая таблица' RIGHT JOIN 'Правая таблица' ON 'Условие объединения';
	  ```  
	- Полное внешнее объединение (FULL JOIN, FULL OUTER JOIN)  
	    
	  > Третий тип внешнего объединения — FULL JOIN. Его работа рассматривается как одновременное применение левого и правого внешних объединений. Полное внешнее объединение не поддерживается во многих СУБД, включая SQLite, и на практике применяется редко.  

- ### Расширенные возможности SQL  
	- Представления  
	    
	  > Представление проще всего определить как именованную выборку. Это срез данных, которому мы даём имя и используем в дальнейшем как виртуальную таблицу.  

	  ```
	  CREATE VIEW 'Имя Представления' AS SELECT ...;
	  ```  
	- Временные таблицы  
	    
	  > Если в процессе работы требуется создать таблицу только для некоторых промежуточных данных,  
	  которые не надо хранить, создаём временную таблицу. Временная таблица создаётся в оперативной памяти системы, её данные не сохраняются на носителе информации. Такая таблица удаляется из памяти сразу после завершения работы текущей сессии пользователя в СУБД.  

	  ```
	  CREATE TEMPORARY TABLE 'table_name' ( ... );
	  ```  
	- Транзакции  
	  ```
	  BEGIN TRANSACTION;
		Операция 1;
		Операция 2;
		...
		Операция N;
	  COMMIT;
	  ```
	- Триггеры  
	    
	  > Триггеры рассматриваются как задачи, которые выполняются автоматически при наступлении конкретного события — вставки строки, обновлении данных, удалении строки.  

	  ```
	  CREATE TRIGGER 'Имя триггера' [BEFORE|AFTER] 'Событие'
	  ON 'Таблица'
	  BEGIN
		-- Действия ....
	  END;
	  ```
	- Создание индексов  
	  ```
	  CREATE INDEX 'Имя индекса' ON 'Имя таблицы'('Имена столбцов');
	  ```
